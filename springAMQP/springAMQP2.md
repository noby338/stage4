# springAMQP2

### 消息的可靠性

![image.png](https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/20230330184622.png)
其中的每一步都可能导致消息丢失，常见的丢失原因包括：

- 发送时丢失：解决方式为生产者确认机制
    - 生产者发送的消息未送达 exchange，到达 publisher-confirm 回调函数（配置在具体的消息发送中）
    - 消息到达 exchange 后未到达 queue， 到达 publisher-return 回调函数（所有消息配置在统一的配置类中）
- MQ 宕机，queue 将消息丢失：解决方式为 mq 持久化
    - 交换机持久化
        - SpringAMQP 默认是持久化的，RabbitMQ 默认不是持久化的
    - 队列持久化
        - SpringAMQP 默认是持久化的，RabbitMQ 默认不是持久化的
    - 消息持久化
        - SpringAMQP 默认是持久化的，RabbitMQ 默认不是持久化的
- consumer 接收到消息后未消费就宕机：解决方式为失败重试机制
    - none 消费者获得消息后，mq则删除队列中的消息
    - auto 模式类似事务机制，出现异常时返回 nack，消息回滚到队列；没有异常，返回 ack，消息删除
        - 当发生异常时，在消息在队列和消费者中无限循环
        - retry模式，发生异常时，消费者在本地尝试若干次后返回ack。
            - 配置异常消息的交换机和队列，消费者在本地尝试若干次后消息进入该队列。
    - manual：自己根据业务情况，判断什么时候该返回 ack

### 延迟消息

- 实现的两种方式
    - 使用死信交换机
        - 发送消息到一个没有消费者的队列，该队列设置过期时间，并且绑定一个死信交换机。当过期时将消息发送至死信交换机路由到死信队列
        - 设置消费者监听死信队列，处理消息
    - 使用rabbitmq自带的延迟插件
        - 将信息投递到延迟交换机，延迟交换机延迟后自动投递到队列，消费者监听该队列。插件的延迟交换机 x-delayed-message 是三种基本交换机之外的另一种特殊交换机，可以将消息存储在内存中，当时间结束则投递给队列

- 哪些消息会进入死信交换机
    - 消费者使用 basic.reject 或 basic.nack 声明消费失败，并且消息的 requeue 参数设置为 false
    - 消息是一个过期消息，超时无人消费（可以实现延迟消息）
    - 要投递的队列消息满了，无法投递

### 消息堆积

- 解决消息堆积有两种思路：
    - 增加更多消费者，提高消费速度。也就是我们之前说的 work queue 模式
    - 扩大队列容积，提高堆积上限
        - 使用惰性队列
            - 接收到消息后直接存入磁盘而非内存
            - 消费者要消费消息时才会从磁盘中读取并加载到内存
            - 支持数百万条的消息存储
    
