- redis 通过 jedis 的基本使用(RedisAPITest.java)
  - jedis 配置文件配置连接池
- springboot 使用 redis(RedisSpringbootTests.java)
  - stringRedisTemplate 的基本使用（使用配置文件配置）
  - redisTemplate 的基本使用(使用配置类和配置文件配置)
  - redisTemplate string 中的常用 API
  - redisTemplate hash 中的常用 API
  - redisTemplate list 中的常用 API
  - redisTemplate set 中的常用 API
  - redisTemplate zset 中的常用 API
  - 业务中使用 redis（StudentServiceImpl）
    - 编程式缓存操作
    - 声明式缓存操作（使用 Springboot 的缓存机制）@cacahable
      - 添加场景启动器依赖
      - 启动类添加启用声明式注解 @EnableCaching
      - 使用类添加相应注解
        - 查询 @Cacheable(value = "student", key = "#id", condition = "#id>3")
          - value 和 key 表示工作空间的命名
          - condition 表示缓存的条件
        - 添加和修改 @CachePut(value = "student",key = "#student.id")
        - 删除 @CacheEvict(value = "student",key = "#id",beforeInvocation = false)
          - beforeInvocation = false 表示删除缓存的动作执行是否在主业务之前
    - redis 实现 session 的中间件（redis session 共享）（LoginController）
      - 添加依赖 spring-session-data-redis
- redis 存在的问题
  - 缓存穿透：是指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，并且处于容错考虑，我们没有将这次查询的 null 写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询。
  - 缓存雪崩：缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。
  - 缓存击穿：不存在缓存的数据在被写入缓存前，被超高并发地访问，导致这个不存在缓存的数据每次请求都要到存储层去查询。
- redis 的线程安全(LockController)
  - redis 的多线程
    - 在单服务器和集群环境下都不存在线程安全问题
  - 自定义多线程
    - 单服务器有问题 使用同步锁可以解决
    - 集群环境有问题 使用分布式锁
      - 分布式锁的使用
        - 配置类(redissonClient)
        - 原理：使用Redis作为一个中间件，获得执行权的进程，向redis存入一个key，当其他线程（其他服务器）发现存在该key时，等待线程执行。当执行完时删除key